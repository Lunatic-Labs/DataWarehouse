"""
This is an example service file. This is where the logic for handling routes will be. 
In this case, the service is based on a specific
 database table. But you can imagine a 
 service that combines two different 
 tables/services in order to serve the 
 purpose it needs to serve.
"""
from datawarehouse.config.db import config as db
from datawarehouse.model import fibonacci
from datawarehouse.service import BaseService

from sqlalchemy import func, insert, delete


# this class is the main service for doing logic for
#  operations relating to the Fibonacci table in the database.
# It is a subclass of the BaseService, defined elsewhere.
#  It will also have any capabilities that the base service has.
class FibonacciService(BaseService):
    session = db.session
    # Gets the highest id (or the last number generated by the fibonacci sequence)
    @classmethod
    def get_last_id(self):
        last_id = self.session.query(func.max(fibonacci.c.id)).scalar()
        return last_id

    # gets the number given a 0-based index.
    # value -1 will return the last number
    @classmethod
    def get_number_from_relative_id(self, id=-1):
        first_number_id = 0
        if id == -1:
            id = self.get_last_id()
        else:
            first_number_id = (
                self.session.query(fibonacci.c.id)
                .where(fibonacci.c.number == 0)
                .first()
                .id
            )
        return str(self.get_number(first_number_id + int(id)))

    # gets a number given a true index
    @classmethod
    def get_number(self, index=0):
        id = index or self.session.query(func.max(fibonacci.c.id)).scalar()
        return (
            self.session.query(fibonacci.c.number).where(fibonacci.c.id == id).scalar()
        )

    # increments the fibonacci sequence by the specified ammount.
    @classmethod
    def increment_n_times(self, increment=1):
        for i in range(increment):
            last_id = self.get_last_id()
            last_no = self.get_number(last_id)
            sec_last_no = self.get_number(last_id - 1) if last_id > 1 else 0
            stmt = insert(fibonacci).values(number=last_no + sec_last_no)
            try:
                self.session.execute(stmt)
                self.session.commit()
            except:
                self.session.rollback()
                return "failed. The numbers are probably too high. Ping the api/fibonacci/reset/ endpoint to reset the numbers."

        return str(last_no + sec_last_no)

    # resets the fibonacci sequence and replaces the first two numbers
    @classmethod
    def reset(self):
        self.session.execute(delete(fibonacci))
        self.session.execute(fibonacci.insert().values(number=0))
        self.session.execute(fibonacci.insert().values(number=1))
        self.session.commit()
        return
